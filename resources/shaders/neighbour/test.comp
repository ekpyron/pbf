#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

struct ParticleData {
    vec3 position;
    uint aux;
};

layout(std430, binding = 0, set = 0) buffer Particles
{
    ParticleData particles[];
};

struct GridBoundaries {
    uint startIndex;
    uint endIndex;
};

layout(std140, binding = 1, set = 0) uniform GridData {
    ivec3 GRID_MAX;
    ivec3 GRID_MIN;
    ivec3 GRID_HASHWEIGHTS;
};

layout(std430, binding = 0, set = 1) readonly buffer GridBoundaryBuffer
{
    GridBoundaries grid[]; // .x: start; .y: end
};

uint GetGridIndex(vec3 position) {
    highp ivec3 grid = ivec3 (clamp (position, GRID_MIN, GRID_MAX));
    return uint (dot (grid - GRID_MIN, GRID_HASHWEIGHTS));
}


#define FOR_EACH_NEIGHBOUR(gid, idx) \
for (int _x = -1; _x <= 1; ++_x) { \
for (int _y = -1; _y <= 1; ++_y) { \
for (int _z = -1; _z <= 1; ++_z) { \
vec3 _position = particles[gid].position + vec3(_x,_y,_z); \
if (!(any(lessThan(_position, vec3(GRID_MIN)))) && all(lessThan(_position, vec3(GRID_MAX)))) { \
GridBoundaries _gridCell = grid[GetGridIndex(particles[gid].position + vec3(_x,_y,_z))]; \
for (uint idx = _gridCell.startIndex; idx < _gridCell.endIndex; ++idx) { \
if (idx != gid) { \
if (distance(particles[idx].position, particles[gid].position) < 1.0) {

#define END_FOR_EACH_NEIGHBOUR() }}}}}}}



void main (void)
{
    uint gid;
    gid = gl_GlobalInvocationID.x;

    uint myGridIndex = GetGridIndex(particles[gid].position);

    if (particles[gid].aux == -1u) {
        FOR_EACH_NEIGHBOUR(gid, idx)
            particles[idx].aux = 1;
        END_FOR_EACH_NEIGHBOUR()
    }

#if 0
    //particles[grid[myGridIndex].startIndex].aux = grid[myGridIndex].startIndex;
    if (particles[gid].aux == -1) {
        for (uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            particles[idx].aux = 1;
        }
        particles[grid[myGridIndex].startIndex].aux = 2;
        particles[grid[myGridIndex].endIndex - 1].aux = 3;
    }
#endif

#if 0
    if (particles[gid].aux > 1) {
        particles[grid[myGridIndex].startIndex].aux = 1;
        /*
        for(uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            if (particles[idx].aux != 1.0)
                particles[idx].aux = 0.5;
        }
        */
    }
#endif
#if 0
    if (grid[myGridIndex].startIndex <= gid && gid < grid[myGridIndex].endIndex) {
        particles[gid].aux = -1u;
    }

        bool pass = true;
        for(uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            pass = pass && GetGridIndex(particles[idx].position) == myGridIndex;
        }

           particles[gid].aux = pass ? -1u : 0u;
#endif
#if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].startIndex].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = -1u; // float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
#endif
#if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].endIndex - 1].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = -1u;// float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
#endif
    /*

    uint gridIndex = GetGridIndex();
    if (gid >= grid[gridIndex].startIndex && gid < grid[gridIndex].endIndex)
        particles[gid].aux = 1.0;
        */
}
