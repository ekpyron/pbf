#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

struct ParticleData {
    vec3 position;
    float aux;
};

layout(std430, binding = 0, set = 0) buffer Particles
{
    ParticleData particles[];
};

struct GridBoundaries {
    uint startIndex;
    uint endIndex;
};

layout(std140, binding = 1, set = 0) uniform GridData {
    ivec3 GRID_MAX;
    ivec3 GRID_MIN;
    ivec3 GRID_HASHWEIGHTS;
};

layout(std430, binding = 0, set = 1) readonly buffer GridBoundaryBuffer
{
    GridBoundaries grid[]; // .x: start; .y: end
};

uint GetGridIndex(vec3 position) {
    highp ivec3 grid = ivec3 (clamp (position, GRID_MIN, GRID_MAX));
    return uint (dot (grid - GRID_MIN, GRID_HASHWEIGHTS));
}


void main (void)
{
    uint gid;
    gid = gl_GlobalInvocationID.x;

    uint myGridIndex = GetGridIndex(particles[gid].position);

    #if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].startIndex].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = 1.0; // float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
    #endif
    /*

    uint gridIndex = GetGridIndex();
    if (gid >= grid[gridIndex].startIndex && gid < grid[gridIndex].endIndex)
        particles[gid].aux = 1.0;
        */
}
