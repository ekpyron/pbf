#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;
layout (constant_id = 1) const int MAX_ID = 1;

struct ParticleData {
    vec3 position;
    uint aux;
};

layout(std430, binding = 0, set = 0) readonly buffer Particles
{
    ParticleData particles[];
};

struct GridBoundaries {
    uint startIndex;
    uint endIndex;
};

layout(std140, binding = 1, set = 0) uniform GridData {
    ivec3 GRID_MAX;
    ivec3 GRID_MIN;
    ivec3 GRID_HASHWEIGHTS;
};

layout(std430, binding = 0, set = 1) writeonly buffer GridBoundaryBuffer
{
    GridBoundaries grid[]; // .x: start; .y: end
};

uint GetGridIndex(vec3 position) {
    ivec3 gridPositive = ivec3(floor(position)) - GRID_MIN.xyz;
    return uint(gridPositive.x * GRID_HASHWEIGHTS.x + gridPositive.y * GRID_HASHWEIGHTS.y + gridPositive.z * GRID_HASHWEIGHTS.z);
}

void main (void)
{
    uint gid;
    gid = gl_GlobalInvocationID.x;

    if (gid == 0)
    {
        grid[GetGridIndex(particles[0].position)].startIndex = 0;
        //uint maxID = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
        //grid[GetGridIndex(GRID_MAX)].endIndex = maxID;
        grid[GetGridIndex(particles[MAX_ID - 1].position)].endIndex = MAX_ID;
        return;
    }

    uint currentGridIndex = GetGridIndex(particles[gid].position);
    uint previousGridIndex = GetGridIndex(particles[gid - 1].position);

    if (currentGridIndex != previousGridIndex)
    {
        // TODO: race conditions?
        grid[currentGridIndex].startIndex = gid;
        grid[previousGridIndex].endIndex = gid;
    }
}
