#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "common.comp"

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0, set = 0) readonly buffer ParticleKeys
{
    ParticleKey particleKeys[];
};

layout(std430, binding = 0, set = 2) readonly buffer LambdaBuffer
{
    float lambdas[];
};

layout(std430, binding = 0, set = 3) writeonly buffer OutputParticleKeys
{
    ParticleKey outputParticleKeys[];
};


layout(std430, binding = 0, set = 4) readonly buffer Particles
{
    ParticleData particles[];
};


void main(void)
{
    uint gid = gl_GlobalInvocationID.x;
    ParticleKey key = particleKeys[gid];
    vec3 position = key.position;
    uint type = particles[key.index].type;

    vec3 deltap = vec3 (0, 0, 0);

    float lambda = lambdas[gid];

    FOR_EACH_NEIGHBOUR(gid, j)
    {
        ParticleKey key_j = particleKeys[j];
        vec3 position_j = key_j.position;
        uint type_j = particles[key_j.index].type;
        vec3 p_ij = position - position_j;
        float len = length (p_ij);
        vec3 grad = gradWspiky(p_ij);

        float scorr = tensile_instability_scale * Wpoly6 (len);
        scorr *= scorr;
        scorr *= scorr;
        scorr = -tensile_instability_k * scorr;

        // accumulate position corrections (part of equation 12)
        deltap += (lambda + lambdas[j] + scorr) * grad;

        deltap += (len < 1.2 ? 1 : 0) * ((type == type_j) ? 0.0 : -1.0) * ((0.10 * (len - 1.2)) / len * p_ij);
    }
    END_FOR_EACH_NEIGHBOUR()

    position += one_over_rho_0 * deltap;

    // Cylinder Z
    /* position.z = clamp(position.z, 1, 63);
    vec2 center = vec2(32, 32);
    vec2 ptr = position.xy - center;
    float dist = length(ptr);
    ptr /= dist;
    if (dist > 28) {
        position.xy = center + 28 * ptr;
    }
    */

    // Cylinder y
    /*{
    position.y = clamp(position.y, 1, 63);
    vec2 center = vec2(32, 32);
    vec2 ptr = position.xz - center;
    float dist = length(ptr);
    ptr /= dist;
    if (dist > 28) {
        position.xz = center + 28 * ptr;
    }
    }*/

    // Sphere
    /*{
    vec3 center = vec3(32,32,32);
    vec3 ptr = position - center;
    float dist = length (ptr);
    ptr /= dist;
    if (dist > 28) {
        position =  center + 28 * ptr;
    }
    }*/

    // Cube
    // position = clamp (position, vec3(-64,-64,-64), vec3(63,63,63));

    // Cube with pseudo-reflective boundaries.

/*
    position *= vec3(lessThan(position, vec3(-64,-64,-64))) * (-2) + 1;
    position *= vec3(greaterThan(position, vec3(63,63,63))) * (-2) + 1;
*/
    position = clamp (position, vec3(-100,-100,-100), vec3(100,100,100));

    outputParticleKeys[gid].position = position;
    outputParticleKeys[gid].index = particleKeys[gid].index;
}