#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

const uint HALFBLOCKSIZE = gl_WorkGroupSize.x;
const uint BLOCKSIZE = 2 * HALFBLOCKSIZE;

shared highp uint tmp[BLOCKSIZE];


layout(std430, binding = 0) buffer BlockSumInput
{
    uint data[];
};


layout(std430, binding = 1) writeonly buffer BlockSumOutput
{
    uint blocksums[];
};

void do_scan() {

    int offset = 1;
    for (uint d = HALFBLOCKSIZE; d > 0; d >>= 1)
    {
        barrier();
        memoryBarrier();

        if (gl_LocalInvocationIndex < d) {
            uint i = offset * (2 * gl_LocalInvocationIndex + 1) - 1;
            uint j = offset * (2 * gl_LocalInvocationIndex + 2) - 1;
            tmp[j] += tmp[i];
        }
        offset <<= 1;
    }

    barrier();
    memoryBarrier();

    // if (subGroupElect())
    {
        if (gl_LocalInvocationIndex == 0)
        {
            blocksums[gl_WorkGroupID.x] = tmp[BLOCKSIZE - 1];
            tmp[BLOCKSIZE - 1] = 0;
        }
    }

    for (uint d = 1; d < BLOCKSIZE; d <<= 1)
    {
        offset >>= 1;
        barrier();
        memoryBarrier();

        if (gl_LocalInvocationIndex < d)
        {
            uint i = offset * (2 * gl_LocalInvocationIndex + 1) - 1;
            uint j = offset * (2 * gl_LocalInvocationIndex + 2) - 1;
            uint t = tmp[i];
            tmp[i] = tmp[j];
            tmp[j] += t;
        }
    }

    barrier ();
    memoryBarrierShared ();

    data[gl_WorkGroupID.x * BLOCKSIZE + 2 * gl_LocalInvocationIndex] = tmp[2 * gl_LocalInvocationIndex];
    data[gl_WorkGroupID.x * BLOCKSIZE + 2 * gl_LocalInvocationIndex + 1] = tmp[2 * gl_LocalInvocationIndex + 1];

}