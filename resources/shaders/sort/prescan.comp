#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

/*#define HALFBLOCKSIZE 128
#define BLOCKSIZE (2*HALFBLOCKSIZE)*/
layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

const uint HALFBLOCKSIZE = gl_WorkGroupSize.x;
const uint BLOCKSIZE = 2 * HALFBLOCKSIZE;

struct ParticleData {
    vec3 position;
    float aux;
};

layout(std430, binding = 2) readonly buffer particleInputData
{
    ParticleData inputData[];
};


layout(std430, binding = 0) writeonly buffer ParticleSortKeys
{
    uint particleSortKeys[];
};

layout(std430, binding = 3) writeonly buffer particleOutputData
{
    ParticleData outputData[];
};

layout(std430, binding = 1) writeonly buffer BlockSumOutput
{
    uint blocksums[];
};


highp ivec3 GRID_HASHWEIGHTS = ivec3(1, 64, 64*64);
highp ivec3 GRID_MAX = ivec3(1023, 31, 31);
highp ivec3 GRID_MIN = ivec3(-32, -32, -32);

highp uint GetHash (in vec3 pos)
{
    highp ivec3 grid = ivec3 (clamp (pos.xyz, GRID_MIN, GRID_MAX));
    return uint (dot (grid - GRID_MIN, GRID_HASHWEIGHTS));
}

layout(push_constant) uniform constants {
    int selectedBit;
};

shared highp uint tmp[BLOCKSIZE];

void do_scan();

void main() {

    // gl_WorkGroupID.x
    // gl_LocalInvocationIndex

    ParticleData currentParticle1 = inputData[gl_WorkGroupID.x * BLOCKSIZE + 2 * gl_LocalInvocationIndex];
    ParticleData currentParticle2 = inputData[gl_WorkGroupID.x * BLOCKSIZE + 2 * gl_LocalInvocationIndex + 1];
    uint hash1 = GetHash(currentParticle1.position);
    uint hash2 = GetHash(currentParticle2.position);

    tmp[gl_LocalInvocationIndex * 2] = bitfieldExtract(hash1,  selectedBit, 1);
    tmp[gl_LocalInvocationIndex * 2 + 1] = bitfieldExtract(hash2,  selectedBit, 1);

    do_scan();
}
