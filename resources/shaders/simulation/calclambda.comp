#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "common.comp"

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0, set = 0) readonly buffer ParticleKeys
{
    ParticleKey particleKeys[];
};

layout(std430, binding = 0, set = 2) writeonly buffer LambdaBuffer
{
    float lambdas[];
};

layout(std430, binding = 0, set = 3) readonly buffer Particles
{
    ParticleData particles[];
};


void main(void)
{
    uint gid = gl_GlobalInvocationID.x;
    ParticleKey key = particleKeys[gid];
    vec3 position = key.position;

    uint type = particles[key.index].type;

    float sum_k_grad_Ci = 0;
    float rho = 0;

    vec3 grad_pi_Ci = vec3 (0, 0, 0);

    FOR_EACH_NEIGHBOUR(gid, j)
    {
        ParticleKey key_j = particleKeys[j];
        vec3 position_j = key_j.position;
        uint type_j = particles[key_j.index].type;

        vec3 p_ij = position - position_j;

        // compute rho_i (equation 2)
        float len = length(p_ij);
        float tmp = Wpoly6(len);
        rho += tmp;

        // sum gradients of Ci (equation 8 and parts of equation 9)
        // use j as k so that we can stay in the same loop
        vec3 grad_pk_Ci = gradWspiky (p_ij);
        sum_k_grad_Ci += dot(grad_pk_Ci, grad_pk_Ci);

        // now use j as j again and accumulate grad_pi_Ci for the case k=i
        // from equation 8
        grad_pi_Ci += grad_pk_Ci;
    }
    END_FOR_EACH_NEIGHBOUR()

    grad_pi_Ci *= one_over_rho_0;
    sum_k_grad_Ci *= one_over_rho_0 * one_over_rho_0;

    // add grad_pi_Ci to the sum
    sum_k_grad_Ci += dot (grad_pi_Ci, grad_pi_Ci);

    // compute lambda_i (equations 1 and 9)
    float C_i = rho * one_over_rho_0 - 1;
    lambdas[gid] = -C_i / (sum_k_grad_Ci + epsilon);
}