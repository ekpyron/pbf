#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

struct ParticleKey {
    vec3 position;
    uint index;
};

layout(std430, binding = 0, set = 0) buffer ParticleKeys
{
    ParticleKey particleKeys[];
};

struct GridBoundaries {
    uint startIndex;
    uint endIndex;
};

layout(std140, binding = 1, set = 0) uniform GridData {
    ivec3 GRID_MAX;
    ivec3 GRID_MIN;
    ivec3 GRID_HASHWEIGHTS;
};

layout(std430, binding = 0, set = 1) readonly buffer GridBoundaryBuffer
{
    GridBoundaries grid[]; // .x: start; .y: end
};
uint GetGridIndex(vec3 position) {
    ivec3 gridPositive = ivec3(floor(position)) - GRID_MIN.xyz;
    return uint(gridPositive.x * GRID_HASHWEIGHTS.x + gridPositive.y * GRID_HASHWEIGHTS.y + gridPositive.z * GRID_HASHWEIGHTS.z);
}



#define FOR_EACH_NEIGHBOUR(gid, idx) \
for (int _x = -1; _x <= 1; ++_x) { \
for (int _y = -1; _y <= 1; ++_y) { \
for (int _z = -1; _z <= 1; ++_z) { \
vec3 _position = particleKeys[gid].position + vec3(_x,_y,_z); \
if (!(any(lessThan(_position, vec3(GRID_MIN)))) && all(lessThan(_position, vec3(GRID_MAX)))) { \
GridBoundaries _gridCell = grid[GetGridIndex(particleKeys[gid].position + vec3(_x,_y,_z))]; \
for (uint idx = _gridCell.startIndex; idx < _gridCell.endIndex; ++idx) { \
if (idx != gid) { \
if (distance(particleKeys[idx].position, particleKeys[gid].position) < 1.0) {

#define END_FOR_EACH_NEIGHBOUR() }}}}}}}



void main (void)
{
    uint gid;
    gid = gl_GlobalInvocationID.x;

    uint myGridIndex = GetGridIndex(particleKeys[gid].position);

#if 0
    if (particles[gid].aux == -1u) {
        FOR_EACH_NEIGHBOUR(gid, idx)
            particles[idx].aux = 1;
        END_FOR_EACH_NEIGHBOUR()
    }
#endif

#if 0
    //particles[grid[myGridIndex].startIndex].aux = grid[myGridIndex].startIndex;
    if (particles[gid].aux == -1) {
        for (uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            particles[idx].aux = 1;
        }
        particles[grid[myGridIndex].startIndex].aux = 2;
        particles[grid[myGridIndex].endIndex - 1].aux = 3;
    }
#endif

#if 0
    if (particles[gid].aux > 1) {
        particles[grid[myGridIndex].startIndex].aux = 1;
        /*
        for(uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            if (particles[idx].aux != 1.0)
                particles[idx].aux = 0.5;
        }
        */
    }
#endif
#if 0
    if (grid[myGridIndex].startIndex <= gid && gid < grid[myGridIndex].endIndex) {
        particles[gid].aux = -1u;
    }

        bool pass = true;
        for(uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            pass = pass && GetGridIndex(particles[idx].position) == myGridIndex;
        }

           particles[gid].aux = pass ? -1u : 0u;
#endif
#if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].startIndex].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = -1u; // float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
#endif
#if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].endIndex - 1].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = -1u;// float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
#endif
    /*

    uint gridIndex = GetGridIndex();
    if (gid >= grid[gridIndex].startIndex && gid < grid[gridIndex].endIndex)
        particles[gid].aux = 1.0;
        */
}
