#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

struct ParticleData {
    vec3 position;
    uint aux;
};

layout(std430, binding = 0, set = 0) buffer Particles
{
    ParticleData particles[];
};

struct GridBoundaries {
    uint startIndex;
    uint endIndex;
};

layout(std140, binding = 1, set = 0) uniform GridData {
    ivec3 GRID_MAX;
    ivec3 GRID_MIN;
    ivec3 GRID_HASHWEIGHTS;
};

layout(std430, binding = 0, set = 1) readonly buffer GridBoundaryBuffer
{
    GridBoundaries grid[]; // .x: start; .y: end
};

uint GetGridIndex(vec3 position) {
    highp ivec3 grid = ivec3 (clamp (position, GRID_MIN, GRID_MAX));
    return uint (dot (grid - GRID_MIN, GRID_HASHWEIGHTS));
}

void main (void)
{
    uint gid;
    gid = gl_GlobalInvocationID.x;

    uint myGridIndex = GetGridIndex(particles[gid].position);

    #if 0
    if (particles[gid].aux == -1u) {

    for (int x = -1; x <= 1; ++x) {
        for (int y = -1; y <= 1; ++y) {
            for (int z = -1; z <= 1; ++z) {
                GridBoundaries gridCell = grid[GetGridIndex(particles[gid].position + vec3(x,y,z))];
                for (uint idx = gridCell.startIndex; idx < gridCell.endIndex; ++idx)
                {
                    if (idx != gid) {
                        if (distance(particles[idx].position, particles[gid].position) < 1.0) {
                            particles[idx].aux = 1;
                        } else {
                            particles[idx].aux = 2;
                        }
                    }
                }
            }
        }
    }
    }
    #endif

#if 0
    //particles[grid[myGridIndex].startIndex].aux = grid[myGridIndex].startIndex;
    if (particles[gid].aux == -1) {
        for (uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            particles[idx].aux = 1;
        }
        particles[grid[myGridIndex].startIndex].aux = 2;
        particles[grid[myGridIndex].endIndex - 1].aux = 3;
    }
#endif

#if 0
    if (particles[gid].aux > 1) {
        particles[grid[myGridIndex].startIndex].aux = 1;
        /*
        for(uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            if (particles[idx].aux != 1.0)
                particles[idx].aux = 0.5;
        }
        */
    }
#endif

    if (grid[myGridIndex].startIndex <= gid && gid < grid[myGridIndex].endIndex) {
        particles[gid].aux = -1u;
    }

        bool pass = true;
        for(uint idx = grid[myGridIndex].startIndex; idx < grid[myGridIndex].endIndex; ++idx) {
            pass = pass && GetGridIndex(particles[idx].position) == myGridIndex;
        }

           particles[gid].aux = pass ? -1u : 0u;

#if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].startIndex].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = -1u; // float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
#endif
#if 0
    uint newGridIndex = GetGridIndex(particles[grid[myGridIndex].endIndex - 1].position);
    if (myGridIndex == newGridIndex)
        particles[gid].aux = -1u;// float(/*GetGridIndex(particles[grid[myGridIndex].startIndex].position)*/myGridIndex) / (16*64.0*64.0);
#endif
    /*

    uint gridIndex = GetGridIndex();
    if (gid >= grid[gridIndex].startIndex && gid < grid[gridIndex].endIndex)
        particles[gid].aux = 1.0;
        */
}
